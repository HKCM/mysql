## 总结

### 视图(VIEW):  
- 虚拟存在的表，不保存查询结果，只保存查询的SQL逻辑
- 简单、安全(隐藏数据,只显示所需数据)、 数据独立(数据基表发生变化后只需要修改视图的字段名)

### 存储过程(PROCEDURE):
- 事先定义并存储在数据库中的一段SQL语句的集合。 需要用到的时候直接调用即可。
- 可以接收参数，也可以返回数据
- 减少网络交互，提高性能、封装重用 
- 支持逻辑处理,变量、if、case、参数(in/out/inout)、while、repeat、loop、cursor、 handler
- 业务逻辑相对稳定但比较复杂，而且对数据的正确性和完整性要求比较高时，推荐在主要的业务逻辑中使用存储过程。

缺点:
1. 如果想灰度发布，同时存在不同版本的存储过程给不同用户用，这个很难或者没法做
2. 存储过程的源码版本管理肯定不像写传统的java等代码直接方便，需要额外的工具和机制，版本跟踪，版本部署等都需要额外的工作

### 存储函数(FUNCTION):
- 存储函数是有返回值的存储过程，参数类型只能为N类型
- 存储函数可以被存储过程替代

### 触发器(TRIGGER):
- 可以在表数据进行INSERT、UPDATE、DELETE之前或之后触发
- 保证数据完整性、日志记录、数据校验
- 只支持行级触发，不支持语句级触发
- 触发器不推荐使用，触发操作能在业务层解决就在业务层解决，否则很难维护，而且容易产生死锁

### 全局锁
- 对整个数据库实例加锁，加锁后整个实例就处于只读状态
- 性能较差，数据逻辑备份时使用

数据库中加全局锁，是一个比较重的操作，存在以下问题：
- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。

在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。

```shell
mysqldump --single-transaction -uroot –p123456 itcast > itcast.sql
```

–single-transaction 实际上通过做了下面两个操作 ：
1. 在开始的时候把该 session 的事务隔离级别设置成 repeatable read ；
2. 然后启动一个事务（执行 begin ），备份结束的时候结束该事务（执行 commit ）

### 表级锁
- 操作锁住整张表，锁定粒度大，发生锁冲突的概率高
- 表锁: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。
- 元数据锁: MDL(meta data lock)加锁过程是系统自动控制,为了避免DML与DDL冲突，保证读写的正确性。(我读数据的时候你不能改表结构)
- 意向锁: 为了避免DML在执行时行锁与表锁的冲突,使用意向锁来减少表锁的检查 (我更新数据的时候你别来看)

### 行级锁
- 操作锁住对应的行数据，锁定粒度最小，发生锁冲突的概率最低,行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的
锁。
- 行锁(Record Lock)：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
- 间隙锁(Gap Lock)：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持
- 临键锁(Next-Key Lock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

## 事务

事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系
统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

InnoDB特点: 事务,外键,行级锁

### redo log

重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。

该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo log file)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。

原理:
1. 在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据
2. 如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中
3. 然后将缓冲池中的数据修改，修改后的数据页我们称为脏页(缓冲池中的数据与磁盘中的数据不一致)
4. 脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致
5. 缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中
6. 刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了

redo log作用:
1. 当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中
2. 在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中
3. 如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复
4. 如果脏页成功刷新到磁盘或涉及到的数据已经落盘，此时redo log就没有作用了，就可以删除，所以存在的两个redo log文件是循环的。

那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?

因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。


### undo Log

回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC(多版本并发控制)。

undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update-一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。

Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。

### 四大特性

- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。通过undo log实现
- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。通过undo log和redo log实现
- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。通过锁和MVCC实现.
- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。通过redo log实现

而对于这四大特性，实际上分为两个部分。 
- 原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 
- 隔离性是通过数据库的锁，加上MVCC来保证的。

### MVCC

全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。

MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、ReadView。

- 通过隐式字段事务ID和回滚指针形成undo log版本链
- ReadView是具体的读取规则的体现,RR(可重复度)和RC(读已提交)有不同的ReadView

MVCC配合锁机制最终体现体现就是隔离性

## 索引

### B+tree索引结构的好处

1. 相对于二叉树，层级更少，搜索效率高；
2. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
3. 相对Hash索引，B+tree支持范围匹配及排序操作；

### 索引失效的情况

1. 联合索引没包含最左前缀
2. 索引列上进行运算操作
3. 头部模糊匹配
4. 字符串条件没加引号
5. or 字段没有索引

### 索引设计原则

1. 针对于数据量较大，且查询比较频繁的表建立索引。(大于10000条数据)
2. 针对于常作为查询条件(where)、排序(ORDER BY)、分组(GROUP BY)操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

### 覆盖索引

尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select *。

二级索引存的是字段值本身+主键id。查询的字段不存在就要回表查询(进行第二次查询)

### 前缀索引

当字段类型为字符串(varchar，text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。

此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

前缀长度可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

```sql
-- create index idx_xxxx on table_name(column(n));
-- 计算选择性
select COUNT(distinct substring(email,1,5))/COUNT (*) from tb_user;
-- 创建email前缀为5的索引
create index idx_tb_user_email_5 on table_name(email(5));
```



## 优化

### 插入大量数据

- 批量插入: 一次性插入多条数据(500-1000条), 如果数量待插入数据过多,可以分成多次批量插入.
- 手动事务提交
- 使用MySQL数据库提供的load指令进行插入

### 主键设计原则

- 满足业务需求的情况下，尽量降低主键的长度。因为二级索引的叶子结点中挂的就是主键,所以主键长度低可以节省空间
- 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
- 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。乱序插入可能页分裂.
- 业务操作尽量避免对主键的修改

### SQL性能分析
- 慢查询日志
- profile详情
- explain执行计划

### ORDER BY优化

- Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。
- Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。
- Backward index scan: 反向扫描索引

```sql
create index idx_user_age_phone_aa on tb_user(age,phone);
explain select id,age,phone from tb_user order by age; -- using index 高效
explain select id,age,phone from tb_user order by age , phone; -- using index 高效
explain select id,age,phone from tb_user order by age desc , phone desc; -- 反向扫描索引
-- 根据phone，age进行升序排序，phone在前，age在后
explain select id,age,phone from tb_user order by phone , age; -- Using filesort 不高效
explain select id,age,phone from tb_user order by age asc , phone desc ; -- Using filesort 不高效

-- 创建索引时,指定索引的排序规则
-- age从小到大, phone从大到小
create index idx_user_age_pho_ad on tb_user(age asc, phone desc);
explain select id,age,phone from tb_user order by age asc , phone desc ; -- using index 高效
```

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。 
- 尽量使用覆盖索引。
- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)。 
- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort buffer size(默认256k)。

```sql
show variables like 'sort_buffer_size'; -- 默认256k
```

### COUNT

count()是一个聚合函数，对于返回的结果集，一行行地判断，**如果count函数的参数不是NULL，累计值就加1，否则不加，最后 返回累计值**。

用法:
- count(*): InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。
- count(主键): InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为nul)。
- count(字段)
  - 没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为nul，不为nul，计数累加。 
  - 有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。
- count(1): loDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“T”进去，直接按行进行累加。

按照效率排序的话,count(字段) < count(主键id) < count(1) ≈ count(*)

所以尽量使用count(*).

### UPDATE优化

执行UPDATE时需要根据索引进行更新. 如果使用没有索引的WHERE条件进行UPDATE时是使用表锁.

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。

```sql
-- name字段没有索引,更新语句升级为表锁
update course set name = 'SpringBoot' where name = 'PHP' ;
```

索引失效: 指不满足[索引使用](#索引使用)的条件


